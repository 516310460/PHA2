{"version":3,"file":"components/hash-rate-datafeeds-socket.js","sources":["webpack:///./components/HashRate/datafeeds/socket.js"],"sourcesContent":["class socket {\n  constructor(url = 'wss://api.fcoin.com/v2/ws', options) {\n    this.heartBeatTimer = null\n    this.options = options\n    this.messageMap = {}\n    this.connState = 0\n    this.socket = null\n    this.url = url\n  }\n  doOpen() {\n    if (this.connState) return\n    this.connState = 1\n    this.afterOpenEmit = []\n    const BrowserWebSocket = window.WebSocket || window.MozWebSocket\n    const socket = new BrowserWebSocket(this.url)\n    socket.binaryType = 'arraybuffer'\n    socket.onopen = evt => this.onOpen(evt)\n    socket.onclose = evt => this.onClose(evt)\n    socket.onmessage = evt => this.onMessage(evt.data)\n    socket.onerror = err => this.onError(err)\n    this.socket = socket\n  }\n  onOpen(evt) {\n    this.connState = 2\n    this.heartBeatTimer = setInterval(this.checkHeartbeat.bind(this), 20000)\n    this.onReceiver({\n      Event: 'open'\n    })\n  }\n  checkOpen() {\n    return this.connState === 2\n  }\n  onClose() {\n    this.connState = 0\n    if (this.connState) {\n      this.onReceiver({\n        Event: 'close'\n      })\n    }\n  }\n  send(data) {\n    this.socket.send(JSON.stringify(data))\n    if (this.socket.bufferedAmount === 0) {\n      // 发送完毕\n      // console.log('发送完毕')\n    } else {\n      // 发送还没结束\n      // console.log('发送还没结束')\n    }\n  }\n  emit(data) {\n    return new Promise(resolve => {\n      this.socket.send(JSON.stringify(data))\n      this.on('message', data => {\n        resolve(data)\n      })\n    })\n  }\n  onMessage(message) {\n    try {\n      const data = JSON.parse(message)\n      this.onReceiver({\n        Event: 'message',\n        Data: data\n      })\n    } catch (err) {\n      console.error(' >> Data parsing error:', err)\n    }\n  }\n  checkHeartbeat() {\n    const data = {\n      'cmd': 'ping',\n      'args': [Date.parse(new Date())]\n    }\n    this.send(data)\n  }\n  onError(err) {\n\n  }\n  onReceiver(data) {\n    const callback = this.messageMap[data.Event]\n    if (callback) callback(data.Data)\n  }\n  on(name, handler) {\n    this.messageMap[name] = handler\n  }\n  doClose() {\n    this.socket.close()\n  }\n  destroy() {\n    if (this.heartBeatTimer) {\n      clearInterval(this.heartBeatTimer)\n      this.heartBeatTimer = null\n    }\n    this.doClose()\n    this.messageMap = {}\n    this.connState = 0\n    this.socket = null\n  }\n}\n\nexport default socket\n"],"mappings":";;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAnGA;AACA;AAoGA;;;;A","sourceRoot":""}