{"version":3,"file":"components/hash-rate-js-chart-feed.js","sources":["webpack:///./components/HashRate/js/chart-provider.js","webpack:///./components/HashRate/js/chart-stream.js","webpack:///./components/HashRate/js/chart-feed.js"],"sourcesContent":["export default {\n  history: {},\n  timer: {},\n  pollingtimer: {},\n  subs: [],\n  init() {\n    this.history = {}\n    this.timer = {}\n    this.subs = []\n  },\n  formatBar: function (data, this_vue, symbolInfo, overrides, newmoney) {\n    const sub = this.subs.find(e => e.symbolInfo === symbolInfo.name)\n    if (!sub || !sub.lastBar) {\n      return false\n    }\n\n    const lastBar = sub.lastBar\n    let resolution = sub.resolution\n    if (resolution.includes('1D')) {\n      // 1 day in minutes === 1440\n      resolution = 1440\n    } else if (resolution.includes('1W')) {\n      // 1 week in minutes === 10080\n      resolution = 10080\n    }\n\n    const coeff = resolution * 60\n    const lastBarSec = lastBar.time / 1000\n\n    if (!Array.isArray(data)) {\n      data = [data]\n    }\n    data.sort((a, b) => {\n      return a.t - b.t\n    })\n    const bars = data.map(el => {\n      const rounded = Math.floor(el.t / coeff) * coeff\n\n      let _lastbar = {}\n      if (rounded > lastBarSec) {\n        _lastbar = {\n          low: lastBar.close,\n          high: lastBar.close,\n          open: lastBar.close,\n          close: el.c,\n          volume: el.v\n        }\n\n        // create a new candle, use last close as open **PERSONAL CHOICE**\n        _lastbar.time = this_vue.global_get_local_time(el.t).valueOf() //TradingView requires bar time in ms\n      } else {\n        _lastbar = lastBar\n        if (el.c < lastBar.low) {\n          _lastbar.low = el.c\n        } else if (el.c > lastBar.high) {\n          _lastbar.high = el.c\n        }\n        if (!newmoney && (resolution.toString() == '1' || overrides)) {\n          _lastbar.volume = el.v\n        }\n        _lastbar.close = el.c\n      }\n      return _lastbar\n    })\n\n    let issub = true\n\n    //是否订阅\n\n    bars.forEach((item) => {\n      const _last = item\n      if (_last.time < lastBar.time) {\n        return true\n      }\n      //更新最新一条k线\n      setTimeout(() => {\n        sub.listener(_last)\n      }, 6)\n\n      sub.lastBar = _last\n      this.history[symbolInfo.name].lastBar = _last\n    })\n\n    return issub\n  },\n  gettimer(interval) {\n    interval = interval.toString()\n    switch (interval) {\n      case '1':\n        return 2000\n        break;\n      case '5':\n        return 5000\n        break;\n      case '15':\n        return 5000\n        break;\n      case '30':\n        return 5000\n        break;\n      case '60':\n        return 5000\n        break;\n      case '240':\n        return 5000\n        break;\n      case 'D':\n        return 5000\n        break;\n      case '1D':\n        return 5000\n        break;\n      case '1W':\n        return 5000\n        break;\n      case '1M':\n        return 5000\n        break;\n    }\n  },\n  getLastBarsOther: function (this_vue, symbolInfo, resolution, from, to, first, limit) {\n    const _self = this\n    const getKline = function () {\n      this_vue.$store.dispatch(this_vue.$socket.url.quotation_kline_get, {\n          \"type\": this_vue.resolutionInterval,\n          \"size\": 1,\n          \"symble\": this_vue.symbleParameString,\n        })\n        .then(({\n          data\n        }) => {\n          if (data) {\n            const t = _self.timer[symbolInfo.name + '_' + this_vue.resolutionInterval]\n            let sub = _self.subs.find(e => e.symbolInfo === symbolInfo.name)\n            if (!sub) {\n              return\n            }\n            if (t != -1) {\n              sub = _self.formatBar.call(_self, data, this_vue, symbolInfo, true)\n            }\n\n            for (const _t in _self.timer) {\n              clearTimeout(_self.timer[_t])\n              _self.timer[_t] = -1\n            }\n\n            if (sub && t != -1) {\n              _self.timer[symbolInfo.name + '_' + this_vue.resolutionInterval] = setTimeout(getKline, 15000)\n            }\n\n          }\n        })\n    }\n    /*订阅最新价*/\n    this_vue.$pubsub.subscribe(this_vue.$pubsub.changeNewMoney, (sub, res) => {\n      if (res && (res.symble == this_vue.symbleParameString)) {\n        const data = {\n          t: res.ts,\n          c: res.price,\n          v: res.amount\n        }\n        _self.formatBar.call(_self, data, this_vue, symbolInfo, false, true)\n      }\n    })\n    getKline()\n  },\n  getLastBars: function (this_vue, symbolInfo, resolution, from, to, first, limit) {\n    //k线图\n    const _self = this\n    const getKline = function () {\n      this_vue.$store.dispatch(this_vue.$socket.url.quotation_kline_get, {\n          \"type\": this_vue.resolutionInterval,\n          \"size\": 1,\n          \"symble\": this_vue.symbleParameString,\n        })\n        .then(({\n          data\n        }) => {\n          if (data) {\n            const issub = _self.formatBar.call(_self, data, this_vue, symbolInfo)\n\n            for (const _t in _self.pollingtimer) {\n              clearTimeout(_self.pollingtimer[_t])\n              _self.pollingtimer[_t] = -1\n            }\n\n            if (issub) {\n              _self.pollingtimer[symbolInfo.name] = setTimeout(getKline, _self.gettimer(resolution))\n            }\n          }\n        })\n    }\n\n    this_vue.$socket.invoke({\n      sub: this_vue.sub,\n      type: this_vue.$socket.type.quotation_kline_get\n    })\n\n    if (!this_vue.$socket.is()) {\n      getKline()\n    }\n\n    this_vue.$socket.receive(this_vue.$socket.type.quotation_kline_get, (res) => {\n      if (res && res.topic == this_vue.sub) {\n        const data = res.data\n        /*k线是否订阅*/\n        const issub = _self.formatBar.call(_self, data, this_vue, symbolInfo)\n        if (!issub) {\n          this_vue.$socket.uninvoke(this_vue.$socket.type.quotation_kline_get)\n        }\n      }\n    })\n  },\n  getBars: function (this_vue, symbolInfo, resolution, from, to, first, limit) {\n    //k线图\n    let etime = to\n    if (this.history[symbolInfo.name] && this.history[symbolInfo.name].firstBar) {\n      etime = this.history[symbolInfo.name].firstBar.time / 1000\n    }\n    const klineParam = {\n      //'btime': from,\n      'etime': etime,\n      \"type\": this_vue.resolutionInterval,\n      //\"size\": 100,\n      \"symble\": this_vue.symbleParameString,\n    }\n\n    const _self = this\n    const getKline = function () {\n      return this_vue.$store.dispatch('quotation_kline_get', klineParam)\n        .then(({\n          data\n        }) => {\n          if (data) {\n            data.sort((a, b) => {\n              return a.t - b.t\n            })\n            const bars = this_vue.bars = data.map(el => {\n              return {\n                time: this_vue.global_get_local_time(el.t).valueOf(), //TradingView requires bar time in ms\n                low: el.l,\n                high: el.h,\n                open: el.o,\n                close: el.c,\n                volume: el.v\n              }\n            })\n\n            _self.history[symbolInfo.name] = {\n              lastBar: bars[bars.length - 1],\n              firstBar: bars[0]\n            }\n\n            return bars\n          } else {\n            return []\n          }\n        })\n    }\n    return getKline()\n  },\n}\n","import historyProvider from './chart-provider.js'\n\nexport default {\n  subscribeBars: function (symbolInfo, resolution, updateCb, uid, resetCache) {\n    const _l = historyProvider.history[symbolInfo.name] ? historyProvider.history[symbolInfo.name].lastBar : null\n    const newSub = {\n      uid,\n      resolution,\n      symbolInfo: symbolInfo.name,\n      lastBar: _l,\n      listener: updateCb,\n    }\n    historyProvider.subs.push(newSub)\n  },\n  unsubscribeBars: function (uid) {\n    const subIndex = historyProvider.subs.findIndex(e => e.uid === uid)\n    if (subIndex === -1) {\n      return\n    }\n    historyProvider.subs.splice(subIndex, 1)\n  }\n}\n","import stream from './chart-stream.js'\nimport historyProvider from './chart-provider.js'\n\nconst resolutions = [\"1\", \"5\", \"10\", \"15\", \"30\", \"60\", \"120\", \"240\", \"360\", \"720\", \"4H\", \"1D\", \"1W\", \"1M\"]\n\nexport default {\n  //创建feed\n  createFeed: function (this_vue) {\n    historyProvider.init()\n    return {\n      onReady: cb => {\n        setTimeout(() => cb({\n          supported_resolutions: resolutions\n        }), 0)\n      },\n      searchSymbols: (userInput, exchange, symbolType, onResultReadyCallback) => {},\n      resolveSymbol: (symbolName, onSymbolResolvedCallback, onResolveErrorCallback) => {\n        const symbol_stub = {\n          name: this_vue.from + \":\" + this_vue.to,\n          ticker: this_vue.from + \":\" + this_vue.to,\n          type: 'crypto',\n          session: '24x7',\n          regular_session: '24x7',\n          minmov: 1,\n          pricescale: 100000000,\n          has_intraday: true,\n          has_daily: true,\n          has_weekly_and_monthly: true,\n          volume_precision: 8,\n          data_status: 'streaming',\n          intraday_multipliers: resolutions,\n          timezone: this_vue.timezone\n        }\n\n        if (this_vue.to.toUpperCase().match(/USD|EUR|JPY|AUD|GBP|KRW|CNY/)) {\n          symbol_stub.pricescale = 100\n        }\n        setTimeout(() => {\n          onSymbolResolvedCallback(symbol_stub)\n        }, 0)\n      },\n      getBars: function (symbolInfo, resolution, from, to, onHistoryCallback, onErrorCallback, firstDataRequest) {\n        /*                        console.log('from----------', this_vue.global_get_local_time(from).format('YYYY-MM-DD HH:mm:ss'),from)\n                                console.log('to----------', this_vue.global_get_local_time(to).format('YYYY-MM-DD HH:mm:ss'),to)*/\n        historyProvider.getBars(this_vue, symbolInfo, resolution, from, to, firstDataRequest)\n          .then(bars => {\n            if (bars.length) {\n              setTimeout(() => {\n                onHistoryCallback(bars)\n                /*一分钟，5分钟 订阅最后一条*/\n                if (firstDataRequest && ['1', '5'].indexOf(resolution) >= 0) {\n                  //监听最后一条数据socket\n                  historyProvider.getLastBars(this_vue, symbolInfo, resolution, from, to, firstDataRequest)\n                  /*获取最后一条数据接口*/\n                  historyProvider.getLastBarsOther(this_vue, symbolInfo, resolution, from, to, firstDataRequest)\n                }\n              }, 6)\n            } else {\n              setTimeout(() => {\n                onHistoryCallback(bars, {\n                  noData: true\n                })\n              }, 6)\n            }\n          }).catch(err => {\n            onErrorCallback(err)\n          })\n      },\n      subscribeBars: (symbolInfo, resolution, onTick, subscriberUID, onResetCacheNeededCallback) => {\n        stream.subscribeBars(symbolInfo, resolution, onTick, subscriberUID, onResetCacheNeededCallback)\n      },\n      unsubscribeBars: subscriberUID => {\n        stream.unsubscribeBars(subscriberUID)\n      },\n      calculateHistoryDepth: (resolution, resolutionBack, intervalBack) => {},\n      getMarks: (symbolInfo, startDate, endDate, onDataCallback, resolution) => {\n        var markssss = function(){\n          var that = this;\n          var id = 1;\n          var time = Date.parse(new Date())/1000;\n          var color = { border: '#103bff', background: '#ff00e9' };\n          var text = '这是标记: ';\n          var label = 'S';\n          var labelFontColor = '#ff8e53';\n          var minSize = 5;\n          var marks = [];\n          for(var i=0;i<15;i++){\n              var mark = {};\n              mark.id = id++;\n              mark.time = time;\n              time -= 28800;\n              mark.color = color;\n              mark.text = text + (id-1);\n              mark.label = label;\n              mark.labelFontColor = labelFontColor;\n              mark.minSize = minSize;\n              marks.push(mark);\n          }\n          return marks;\n        };\n        setTimeout(function () {\n          onDataCallback(markssss);\n        }, 3000);\n        //optional\n      },\n      getTimeScaleMarks: (symbolInfo, startDate, endDate, onDataCallback, resolution) => {\n        //optional\n      },\n      getServerTime: cb => {\n\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAQA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AA9BA;AAgCA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AADA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAOA;AACA;AAAA;AACA;AAEA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AApQA;;;;;;;;ACAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAlBA;;;;;;;;ACFA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AACA;AAgBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAnGA;AAuGA;AA3GA;;;;A","sourceRoot":""}