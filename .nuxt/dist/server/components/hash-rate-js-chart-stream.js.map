{"version":3,"file":"components/hash-rate-js-chart-stream.js","sources":["webpack:///./components/HashRate/js/chart-provider.js","webpack:///./components/HashRate/js/chart-stream.js"],"sourcesContent":["export default {\n  history: {},\n  timer: {},\n  pollingtimer: {},\n  subs: [],\n  init() {\n    this.history = {}\n    this.timer = {}\n    this.subs = []\n  },\n  formatBar: function (data, this_vue, symbolInfo, overrides, newmoney) {\n    const sub = this.subs.find(e => e.symbolInfo === symbolInfo.name)\n    if (!sub || !sub.lastBar) {\n      return false\n    }\n\n    const lastBar = sub.lastBar\n    let resolution = sub.resolution\n    if (resolution.includes('1D')) {\n      // 1 day in minutes === 1440\n      resolution = 1440\n    } else if (resolution.includes('1W')) {\n      // 1 week in minutes === 10080\n      resolution = 10080\n    }\n\n    const coeff = resolution * 60\n    const lastBarSec = lastBar.time / 1000\n\n    if (!Array.isArray(data)) {\n      data = [data]\n    }\n    data.sort((a, b) => {\n      return a.t - b.t\n    })\n    const bars = data.map(el => {\n      const rounded = Math.floor(el.t / coeff) * coeff\n\n      let _lastbar = {}\n      if (rounded > lastBarSec) {\n        _lastbar = {\n          low: lastBar.close,\n          high: lastBar.close,\n          open: lastBar.close,\n          close: el.c,\n          volume: el.v\n        }\n\n        // create a new candle, use last close as open **PERSONAL CHOICE**\n        _lastbar.time = this_vue.global_get_local_time(el.t).valueOf() //TradingView requires bar time in ms\n      } else {\n        _lastbar = lastBar\n        if (el.c < lastBar.low) {\n          _lastbar.low = el.c\n        } else if (el.c > lastBar.high) {\n          _lastbar.high = el.c\n        }\n        if (!newmoney && (resolution.toString() == '1' || overrides)) {\n          _lastbar.volume = el.v\n        }\n        _lastbar.close = el.c\n      }\n      return _lastbar\n    })\n\n    let issub = true\n\n    //是否订阅\n\n    bars.forEach((item) => {\n      const _last = item\n      if (_last.time < lastBar.time) {\n        return true\n      }\n      //更新最新一条k线\n      setTimeout(() => {\n        sub.listener(_last)\n      }, 6)\n\n      sub.lastBar = _last\n      this.history[symbolInfo.name].lastBar = _last\n    })\n\n    return issub\n  },\n  gettimer(interval) {\n    interval = interval.toString()\n    switch (interval) {\n      case '1':\n        return 2000\n        break;\n      case '5':\n        return 5000\n        break;\n      case '15':\n        return 5000\n        break;\n      case '30':\n        return 5000\n        break;\n      case '60':\n        return 5000\n        break;\n      case '240':\n        return 5000\n        break;\n      case 'D':\n        return 5000\n        break;\n      case '1D':\n        return 5000\n        break;\n      case '1W':\n        return 5000\n        break;\n      case '1M':\n        return 5000\n        break;\n    }\n  },\n  getLastBarsOther: function (this_vue, symbolInfo, resolution, from, to, first, limit) {\n    const _self = this\n    const getKline = function () {\n      this_vue.$store.dispatch(this_vue.$socket.url.quotation_kline_get, {\n          \"type\": this_vue.resolutionInterval,\n          \"size\": 1,\n          \"symble\": this_vue.symbleParameString,\n        })\n        .then(({\n          data\n        }) => {\n          if (data) {\n            const t = _self.timer[symbolInfo.name + '_' + this_vue.resolutionInterval]\n            let sub = _self.subs.find(e => e.symbolInfo === symbolInfo.name)\n            if (!sub) {\n              return\n            }\n            if (t != -1) {\n              sub = _self.formatBar.call(_self, data, this_vue, symbolInfo, true)\n            }\n\n            for (const _t in _self.timer) {\n              clearTimeout(_self.timer[_t])\n              _self.timer[_t] = -1\n            }\n\n            if (sub && t != -1) {\n              _self.timer[symbolInfo.name + '_' + this_vue.resolutionInterval] = setTimeout(getKline, 15000)\n            }\n\n          }\n        })\n    }\n    /*订阅最新价*/\n    this_vue.$pubsub.subscribe(this_vue.$pubsub.changeNewMoney, (sub, res) => {\n      if (res && (res.symble == this_vue.symbleParameString)) {\n        const data = {\n          t: res.ts,\n          c: res.price,\n          v: res.amount\n        }\n        _self.formatBar.call(_self, data, this_vue, symbolInfo, false, true)\n      }\n    })\n    getKline()\n  },\n  getLastBars: function (this_vue, symbolInfo, resolution, from, to, first, limit) {\n    //k线图\n    const _self = this\n    const getKline = function () {\n      this_vue.$store.dispatch(this_vue.$socket.url.quotation_kline_get, {\n          \"type\": this_vue.resolutionInterval,\n          \"size\": 1,\n          \"symble\": this_vue.symbleParameString,\n        })\n        .then(({\n          data\n        }) => {\n          if (data) {\n            const issub = _self.formatBar.call(_self, data, this_vue, symbolInfo)\n\n            for (const _t in _self.pollingtimer) {\n              clearTimeout(_self.pollingtimer[_t])\n              _self.pollingtimer[_t] = -1\n            }\n\n            if (issub) {\n              _self.pollingtimer[symbolInfo.name] = setTimeout(getKline, _self.gettimer(resolution))\n            }\n          }\n        })\n    }\n\n    this_vue.$socket.invoke({\n      sub: this_vue.sub,\n      type: this_vue.$socket.type.quotation_kline_get\n    })\n\n    if (!this_vue.$socket.is()) {\n      getKline()\n    }\n\n    this_vue.$socket.receive(this_vue.$socket.type.quotation_kline_get, (res) => {\n      if (res && res.topic == this_vue.sub) {\n        const data = res.data\n        /*k线是否订阅*/\n        const issub = _self.formatBar.call(_self, data, this_vue, symbolInfo)\n        if (!issub) {\n          this_vue.$socket.uninvoke(this_vue.$socket.type.quotation_kline_get)\n        }\n      }\n    })\n  },\n  getBars: function (this_vue, symbolInfo, resolution, from, to, first, limit) {\n    //k线图\n    let etime = to\n    if (this.history[symbolInfo.name] && this.history[symbolInfo.name].firstBar) {\n      etime = this.history[symbolInfo.name].firstBar.time / 1000\n    }\n    const klineParam = {\n      //'btime': from,\n      'etime': etime,\n      \"type\": this_vue.resolutionInterval,\n      //\"size\": 100,\n      \"symble\": this_vue.symbleParameString,\n    }\n\n    const _self = this\n    const getKline = function () {\n      return this_vue.$store.dispatch('quotation_kline_get', klineParam)\n        .then(({\n          data\n        }) => {\n          if (data) {\n            data.sort((a, b) => {\n              return a.t - b.t\n            })\n            const bars = this_vue.bars = data.map(el => {\n              return {\n                time: this_vue.global_get_local_time(el.t).valueOf(), //TradingView requires bar time in ms\n                low: el.l,\n                high: el.h,\n                open: el.o,\n                close: el.c,\n                volume: el.v\n              }\n            })\n\n            _self.history[symbolInfo.name] = {\n              lastBar: bars[bars.length - 1],\n              firstBar: bars[0]\n            }\n\n            return bars\n          } else {\n            return []\n          }\n        })\n    }\n    return getKline()\n  },\n}\n","import historyProvider from './chart-provider.js'\n\nexport default {\n  subscribeBars: function (symbolInfo, resolution, updateCb, uid, resetCache) {\n    const _l = historyProvider.history[symbolInfo.name] ? historyProvider.history[symbolInfo.name].lastBar : null\n    const newSub = {\n      uid,\n      resolution,\n      symbolInfo: symbolInfo.name,\n      lastBar: _l,\n      listener: updateCb,\n    }\n    historyProvider.subs.push(newSub)\n  },\n  unsubscribeBars: function (uid) {\n    const subIndex = historyProvider.subs.findIndex(e => e.uid === uid)\n    if (subIndex === -1) {\n      return\n    }\n    historyProvider.subs.splice(subIndex, 1)\n  }\n}\n"],"mappings":";;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAQA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AA9BA;AAgCA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AADA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAOA;AACA;AAAA;AACA;AAEA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AApQA;;;;;;;;ACAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAlBA;;;;A","sourceRoot":""}